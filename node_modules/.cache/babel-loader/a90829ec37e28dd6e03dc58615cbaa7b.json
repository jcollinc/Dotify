{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst percent = require('./percent');\n\nconst dataProperties = require('./data-properties');\n\nconst {\n  CoverageSummary\n} = require('./coverage-summary'); // returns a data object that represents empty coverage\n\n\nfunction emptyCoverage(filePath, reportLogic) {\n  const cov = {\n    path: filePath,\n    statementMap: {},\n    fnMap: {},\n    branchMap: {},\n    s: {},\n    f: {},\n    b: {}\n  };\n  if (reportLogic) cov.bT = {};\n  return cov;\n} // asserts that a data object \"looks like\" a coverage object\n\n\nfunction assertValidObject(obj) {\n  const valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;\n\n  if (!valid) {\n    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\n\nconst keyFromLoc = _ref => {\n  let {\n    start,\n    end\n  } = _ref;\n  return `${start.line}|${start.column}|${end.line}|${end.column}`;\n};\n\nconst mergeProp = function (aHits, aMap, bHits, bMap) {\n  let itemKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : keyFromLoc;\n  const aItems = {};\n\n  for (const [key, itemHits] of Object.entries(aHits)) {\n    const item = aMap[key];\n    aItems[itemKey(item)] = [itemHits, item];\n  }\n\n  for (const [key, bItemHits] of Object.entries(bHits)) {\n    const bItem = bMap[key];\n    const k = itemKey(bItem);\n\n    if (aItems[k]) {\n      const aPair = aItems[k];\n\n      if (bItemHits.forEach) {\n        // should this throw an exception if aPair[0] is not an array?\n        bItemHits.forEach((hits, h) => {\n          if (aPair[0][h] !== undefined) aPair[0][h] += hits;else aPair[0][h] = hits;\n        });\n      } else {\n        aPair[0] += bItemHits;\n      }\n    } else {\n      aItems[k] = [bItemHits, bItem];\n    }\n  }\n\n  const hits = {};\n  const map = {};\n  Object.values(aItems).forEach((_ref2, i) => {\n    let [itemHits, item] = _ref2;\n    hits[i] = itemHits;\n    map[i] = item;\n  });\n  return [hits, map];\n};\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\n\n\nclass FileCoverage {\n  /**\n   * @constructor\n   * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n   * and empty coverage object with the specified file path or a data object that\n   * has all the required properties for a file coverage object.\n   */\n  constructor(pathOrObj) {\n    let reportLogic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!pathOrObj) {\n      throw new Error('Coverage must be initialized with a path or an object');\n    }\n\n    if (typeof pathOrObj === 'string') {\n      this.data = emptyCoverage(pathOrObj, reportLogic);\n    } else if (pathOrObj instanceof FileCoverage) {\n      this.data = pathOrObj.data;\n    } else if (typeof pathOrObj === 'object') {\n      this.data = pathOrObj;\n    } else {\n      throw new Error('Invalid argument to coverage constructor');\n    }\n\n    assertValidObject(this.data);\n  }\n  /**\n   * returns computed line coverage from statement coverage.\n   * This is a map of hits keyed by line number in the source.\n   */\n\n\n  getLineCoverage() {\n    const statementMap = this.data.statementMap;\n    const statements = this.data.s;\n    const lineMap = Object.create(null);\n    Object.entries(statements).forEach(_ref3 => {\n      let [st, count] = _ref3;\n\n      /* istanbul ignore if: is this even possible? */\n      if (!statementMap[st]) {\n        return;\n      }\n\n      const {\n        line\n      } = statementMap[st].start;\n      const prevVal = lineMap[line];\n\n      if (prevVal === undefined || prevVal < count) {\n        lineMap[line] = count;\n      }\n    });\n    return lineMap;\n  }\n  /**\n   * returns an array of uncovered line numbers.\n   * @returns {Array} an array of line numbers for which no hits have been\n   *  collected.\n   */\n\n\n  getUncoveredLines() {\n    const lc = this.getLineCoverage();\n    const ret = [];\n    Object.entries(lc).forEach(_ref4 => {\n      let [l, hits] = _ref4;\n\n      if (hits === 0) {\n        ret.push(l);\n      }\n    });\n    return ret;\n  }\n  /**\n   * returns a map of branch coverage by source line number.\n   * @returns {Object} an object keyed by line number. Each object\n   * has a `covered`, `total` and `coverage` (percentage) property.\n   */\n\n\n  getBranchCoverageByLine() {\n    const branchMap = this.branchMap;\n    const branches = this.b;\n    const ret = {};\n    Object.entries(branchMap).forEach(_ref5 => {\n      let [k, map] = _ref5;\n      const line = map.line || map.loc.start.line;\n      const branchData = branches[k];\n      ret[line] = ret[line] || [];\n      ret[line].push(...branchData);\n    });\n    Object.entries(ret).forEach(_ref6 => {\n      let [k, dataArray] = _ref6;\n      const covered = dataArray.filter(item => item > 0);\n      const coverage = covered.length / dataArray.length * 100;\n      ret[k] = {\n        covered: covered.length,\n        total: dataArray.length,\n        coverage\n      };\n    });\n    return ret;\n  }\n  /**\n   * return a JSON-serializable POJO for this file coverage object\n   */\n\n\n  toJSON() {\n    return this.data;\n  }\n  /**\n   * merges a second coverage object into this one, updating hit counts\n   * @param {FileCoverage} other - the coverage object to be merged into this one.\n   *  Note that the other object should have the same structure as this one (same file).\n   */\n\n\n  merge(other) {\n    if (other.all === true) {\n      return;\n    }\n\n    if (this.all === true) {\n      this.data = other.data;\n      return;\n    }\n\n    let [hits, map] = mergeProp(this.s, this.statementMap, other.s, other.statementMap);\n    this.data.s = hits;\n    this.data.statementMap = map;\n\n    const keyFromLocProp = x => keyFromLoc(x.loc);\n\n    const keyFromLocationsProp = x => keyFromLoc(x.locations[0]);\n\n    [hits, map] = mergeProp(this.f, this.fnMap, other.f, other.fnMap, keyFromLocProp);\n    this.data.f = hits;\n    this.data.fnMap = map;\n    [hits, map] = mergeProp(this.b, this.branchMap, other.b, other.branchMap, keyFromLocationsProp);\n    this.data.b = hits;\n    this.data.branchMap = map; // Tracking additional information about branch truthiness\n    // can be optionally enabled:\n\n    if (this.bT && other.bT) {\n      [hits, map] = mergeProp(this.bT, this.branchMap, other.bT, other.branchMap, keyFromLocationsProp);\n      this.data.bT = hits;\n    }\n  }\n\n  computeSimpleTotals(property) {\n    let stats = this[property];\n\n    if (typeof stats === 'function') {\n      stats = stats.call(this);\n    }\n\n    const ret = {\n      total: Object.keys(stats).length,\n      covered: Object.values(stats).filter(v => !!v).length,\n      skipped: 0\n    };\n    ret.pct = percent(ret.covered, ret.total);\n    return ret;\n  }\n\n  computeBranchTotals(property) {\n    const stats = this[property];\n    const ret = {\n      total: 0,\n      covered: 0,\n      skipped: 0\n    };\n    Object.values(stats).forEach(branches => {\n      ret.covered += branches.filter(hits => hits > 0).length;\n      ret.total += branches.length;\n    });\n    ret.pct = percent(ret.covered, ret.total);\n    return ret;\n  }\n  /**\n   * resets hit counts for all statements, functions and branches\n   * in this coverage object resulting in zero coverage.\n   */\n\n\n  resetHits() {\n    const statements = this.s;\n    const functions = this.f;\n    const branches = this.b;\n    const branchesTrue = this.bT;\n    Object.keys(statements).forEach(s => {\n      statements[s] = 0;\n    });\n    Object.keys(functions).forEach(f => {\n      functions[f] = 0;\n    });\n    Object.keys(branches).forEach(b => {\n      branches[b].fill(0);\n    }); // Tracking additional information about branch truthiness\n    // can be optionally enabled:\n\n    if (branchesTrue) {\n      Object.keys(branchesTrue).forEach(bT => {\n        branchesTrue[bT].fill(0);\n      });\n    }\n  }\n  /**\n   * returns a CoverageSummary for this file coverage object\n   * @returns {CoverageSummary}\n   */\n\n\n  toSummary() {\n    const ret = {};\n    ret.lines = this.computeSimpleTotals('getLineCoverage');\n    ret.functions = this.computeSimpleTotals('f', 'fnMap');\n    ret.statements = this.computeSimpleTotals('s', 'statementMap');\n    ret.branches = this.computeBranchTotals('b'); // Tracking additional information about branch truthiness\n    // can be optionally enabled:\n\n    if (this['bt']) {\n      ret.branchesTrue = this.computeBranchTotals('bT');\n    }\n\n    return new CoverageSummary(ret);\n  }\n\n} // expose coverage data attributes\n\n\ndataProperties(FileCoverage, ['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b', 'bT', 'all']);\nmodule.exports = {\n  FileCoverage\n};","map":{"version":3,"sources":["/Users/mdraghi/Development/code/Phase-3/Phase-3-Project/dotify/node_modules/istanbul-lib-coverage/lib/file-coverage.js"],"names":["percent","require","dataProperties","CoverageSummary","emptyCoverage","filePath","reportLogic","cov","path","statementMap","fnMap","branchMap","s","f","b","bT","assertValidObject","obj","valid","Error","Object","keys","join","keyFromLoc","start","end","line","column","mergeProp","aHits","aMap","bHits","bMap","itemKey","aItems","key","itemHits","entries","item","bItemHits","bItem","k","aPair","forEach","hits","h","undefined","map","values","i","FileCoverage","constructor","pathOrObj","data","getLineCoverage","statements","lineMap","create","st","count","prevVal","getUncoveredLines","lc","ret","l","push","getBranchCoverageByLine","branches","loc","branchData","dataArray","covered","filter","coverage","length","total","toJSON","merge","other","all","keyFromLocProp","x","keyFromLocationsProp","locations","computeSimpleTotals","property","stats","call","v","skipped","pct","computeBranchTotals","resetHits","functions","branchesTrue","fill","toSummary","lines","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst percent = require('./percent');\nconst dataProperties = require('./data-properties');\nconst { CoverageSummary } = require('./coverage-summary');\n\n// returns a data object that represents empty coverage\nfunction emptyCoverage(filePath, reportLogic) {\n    const cov = {\n        path: filePath,\n        statementMap: {},\n        fnMap: {},\n        branchMap: {},\n        s: {},\n        f: {},\n        b: {}\n    };\n    if (reportLogic) cov.bT = {};\n    return cov;\n}\n\n// asserts that a data object \"looks like\" a coverage object\nfunction assertValidObject(obj) {\n    const valid =\n        obj &&\n        obj.path &&\n        obj.statementMap &&\n        obj.fnMap &&\n        obj.branchMap &&\n        obj.s &&\n        obj.f &&\n        obj.b;\n    if (!valid) {\n        throw new Error(\n            'Invalid file coverage object, missing keys, found:' +\n                Object.keys(obj).join(',')\n        );\n    }\n}\n\nconst keyFromLoc = ({ start, end }) =>\n    `${start.line}|${start.column}|${end.line}|${end.column}`;\n\nconst mergeProp = (aHits, aMap, bHits, bMap, itemKey = keyFromLoc) => {\n    const aItems = {};\n    for (const [key, itemHits] of Object.entries(aHits)) {\n        const item = aMap[key];\n        aItems[itemKey(item)] = [itemHits, item];\n    }\n    for (const [key, bItemHits] of Object.entries(bHits)) {\n        const bItem = bMap[key];\n        const k = itemKey(bItem);\n\n        if (aItems[k]) {\n            const aPair = aItems[k];\n            if (bItemHits.forEach) {\n                // should this throw an exception if aPair[0] is not an array?\n                bItemHits.forEach((hits, h) => {\n                    if (aPair[0][h] !== undefined) aPair[0][h] += hits;\n                    else aPair[0][h] = hits;\n                });\n            } else {\n                aPair[0] += bItemHits;\n            }\n        } else {\n            aItems[k] = [bItemHits, bItem];\n        }\n    }\n    const hits = {};\n    const map = {};\n\n    Object.values(aItems).forEach(([itemHits, item], i) => {\n        hits[i] = itemHits;\n        map[i] = item;\n    });\n\n    return [hits, map];\n};\n\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\nclass FileCoverage {\n    /**\n     * @constructor\n     * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n     * and empty coverage object with the specified file path or a data object that\n     * has all the required properties for a file coverage object.\n     */\n    constructor(pathOrObj, reportLogic = false) {\n        if (!pathOrObj) {\n            throw new Error(\n                'Coverage must be initialized with a path or an object'\n            );\n        }\n        if (typeof pathOrObj === 'string') {\n            this.data = emptyCoverage(pathOrObj, reportLogic);\n        } else if (pathOrObj instanceof FileCoverage) {\n            this.data = pathOrObj.data;\n        } else if (typeof pathOrObj === 'object') {\n            this.data = pathOrObj;\n        } else {\n            throw new Error('Invalid argument to coverage constructor');\n        }\n        assertValidObject(this.data);\n    }\n\n    /**\n     * returns computed line coverage from statement coverage.\n     * This is a map of hits keyed by line number in the source.\n     */\n    getLineCoverage() {\n        const statementMap = this.data.statementMap;\n        const statements = this.data.s;\n        const lineMap = Object.create(null);\n\n        Object.entries(statements).forEach(([st, count]) => {\n            /* istanbul ignore if: is this even possible? */\n            if (!statementMap[st]) {\n                return;\n            }\n            const { line } = statementMap[st].start;\n            const prevVal = lineMap[line];\n            if (prevVal === undefined || prevVal < count) {\n                lineMap[line] = count;\n            }\n        });\n        return lineMap;\n    }\n\n    /**\n     * returns an array of uncovered line numbers.\n     * @returns {Array} an array of line numbers for which no hits have been\n     *  collected.\n     */\n    getUncoveredLines() {\n        const lc = this.getLineCoverage();\n        const ret = [];\n        Object.entries(lc).forEach(([l, hits]) => {\n            if (hits === 0) {\n                ret.push(l);\n            }\n        });\n        return ret;\n    }\n\n    /**\n     * returns a map of branch coverage by source line number.\n     * @returns {Object} an object keyed by line number. Each object\n     * has a `covered`, `total` and `coverage` (percentage) property.\n     */\n    getBranchCoverageByLine() {\n        const branchMap = this.branchMap;\n        const branches = this.b;\n        const ret = {};\n        Object.entries(branchMap).forEach(([k, map]) => {\n            const line = map.line || map.loc.start.line;\n            const branchData = branches[k];\n            ret[line] = ret[line] || [];\n            ret[line].push(...branchData);\n        });\n        Object.entries(ret).forEach(([k, dataArray]) => {\n            const covered = dataArray.filter(item => item > 0);\n            const coverage = (covered.length / dataArray.length) * 100;\n            ret[k] = {\n                covered: covered.length,\n                total: dataArray.length,\n                coverage\n            };\n        });\n        return ret;\n    }\n\n    /**\n     * return a JSON-serializable POJO for this file coverage object\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * merges a second coverage object into this one, updating hit counts\n     * @param {FileCoverage} other - the coverage object to be merged into this one.\n     *  Note that the other object should have the same structure as this one (same file).\n     */\n    merge(other) {\n        if (other.all === true) {\n            return;\n        }\n\n        if (this.all === true) {\n            this.data = other.data;\n            return;\n        }\n\n        let [hits, map] = mergeProp(\n            this.s,\n            this.statementMap,\n            other.s,\n            other.statementMap\n        );\n        this.data.s = hits;\n        this.data.statementMap = map;\n\n        const keyFromLocProp = x => keyFromLoc(x.loc);\n        const keyFromLocationsProp = x => keyFromLoc(x.locations[0]);\n\n        [hits, map] = mergeProp(\n            this.f,\n            this.fnMap,\n            other.f,\n            other.fnMap,\n            keyFromLocProp\n        );\n        this.data.f = hits;\n        this.data.fnMap = map;\n\n        [hits, map] = mergeProp(\n            this.b,\n            this.branchMap,\n            other.b,\n            other.branchMap,\n            keyFromLocationsProp\n        );\n        this.data.b = hits;\n        this.data.branchMap = map;\n\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (this.bT && other.bT) {\n            [hits, map] = mergeProp(\n                this.bT,\n                this.branchMap,\n                other.bT,\n                other.branchMap,\n                keyFromLocationsProp\n            );\n            this.data.bT = hits;\n        }\n    }\n\n    computeSimpleTotals(property) {\n        let stats = this[property];\n\n        if (typeof stats === 'function') {\n            stats = stats.call(this);\n        }\n\n        const ret = {\n            total: Object.keys(stats).length,\n            covered: Object.values(stats).filter(v => !!v).length,\n            skipped: 0\n        };\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    computeBranchTotals(property) {\n        const stats = this[property];\n        const ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.values(stats).forEach(branches => {\n            ret.covered += branches.filter(hits => hits > 0).length;\n            ret.total += branches.length;\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    /**\n     * resets hit counts for all statements, functions and branches\n     * in this coverage object resulting in zero coverage.\n     */\n    resetHits() {\n        const statements = this.s;\n        const functions = this.f;\n        const branches = this.b;\n        const branchesTrue = this.bT;\n        Object.keys(statements).forEach(s => {\n            statements[s] = 0;\n        });\n        Object.keys(functions).forEach(f => {\n            functions[f] = 0;\n        });\n        Object.keys(branches).forEach(b => {\n            branches[b].fill(0);\n        });\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (branchesTrue) {\n            Object.keys(branchesTrue).forEach(bT => {\n                branchesTrue[bT].fill(0);\n            });\n        }\n    }\n\n    /**\n     * returns a CoverageSummary for this file coverage object\n     * @returns {CoverageSummary}\n     */\n    toSummary() {\n        const ret = {};\n        ret.lines = this.computeSimpleTotals('getLineCoverage');\n        ret.functions = this.computeSimpleTotals('f', 'fnMap');\n        ret.statements = this.computeSimpleTotals('s', 'statementMap');\n        ret.branches = this.computeBranchTotals('b');\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (this['bt']) {\n            ret.branchesTrue = this.computeBranchTotals('bT');\n        }\n        return new CoverageSummary(ret);\n    }\n}\n\n// expose coverage data attributes\ndataProperties(FileCoverage, [\n    'path',\n    'statementMap',\n    'fnMap',\n    'branchMap',\n    's',\n    'f',\n    'b',\n    'bT',\n    'all'\n]);\n\nmodule.exports = {\n    FileCoverage\n};\n"]},"metadata":{},"sourceType":"script"}